#include <Wire.h>
#include <MPU6050.h>
#include <Servo.h>

// Motor Driver Pins (L298N)
#define IN1 2
#define IN2 3
#define IN3 4
#define IN4 5
#define ENA 9
#define ENB 10

// Servo Objects
Servo servo1;  // Servo 1
Servo servo2;  // Servo 2

// MPU6050 Sensor
MPU6050 mpu;
float yaw = 0;

// Movement Constants
const int baseSpeed = 200;
const float distancePerFoot = 800;
const int turnAngle = 90;
const float gyroSensitivity = 131.0;
const float turnTolerance = 5.0;

// Timing Variables
unsigned long prevTime = 0;
float prevGyroZ = 0;

void setup() {
  Serial.begin(115200);
  
  // Initialize motor pins
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(IN3, OUTPUT);
  pinMode(IN4, OUTPUT);
  pinMode(ENA, OUTPUT);
  pinMode(ENB, OUTPUT);

  // Initialize servos at 0°
  servo1.attach(7);
  servo2.attach(8);
  resetServos();

  // Initialize MPU6050
  Wire.begin();
  mpu.initialize();
  if (!mpu.testConnection()) {
    Serial.println("MPU6050 connection failed!");
    while(1);
  }

  Serial.println("Calibrating MPU6050... Keep sensor flat and still!");
  delay(3000);
  calibrateMPU();
  Serial.println("Calibration complete!");

  // Main navigation sequence
  resetYaw();
  moveStraight(5);  // A -> B
  turnLeft();       // B -> C
  moveStraight(3);  // C -> D
  pauseAtPoint();   // Pause at D with servo movement
  moveStraight(-3); // D -> C
  turnRight();      // C -> E
  moveStraight(5);  // E -> F
  turnLeft();       // F -> G
  moveStraight(3);  // G -> H
  pauseAtPoint();   // Pause at H with servo movement
  moveStraight(-3); // H -> G
  turnRight();      // G -> F
  moveStraight(-10); // F -> A (Final return)
  resetServos();    // Final reset to 0°
}

void loop() {}

void pauseAtPoint() {
  // Move to target positions
  servo1.write(80);
  servo2.write(100);
  delay(5000);      // Wait 5 sec at 80° and 100°
  
  // Reset to 0°
  resetServos();
  delay(3000);      // Wait 3 sec at 0° before continuing
}

void resetServos() {
  servo1.write(0);
  servo2.write(0);
  delay(100);       // Small stabilization delay
}

void calibrateMPU() {
  int16_t ax, ay, az, gx, gy, gz;
  const int samples = 1000;
  long ax_sum = 0, ay_sum = 0, az_sum = 0, gx_sum = 0, gy_sum = 0, gz_sum = 0;

  for (int i = 0; i < samples; i++) {
    mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);
    ax_sum += ax; ay_sum += ay; az_sum += az;
    gx_sum += gx; gy_sum += gy; gz_sum += gz;
    delay(3);
  }

  mpu.setXAccelOffset(-(ax_sum/samples));
  mpu.setYAccelOffset(-(ay_sum/samples));
  mpu.setZAccelOffset(16384 - (az_sum/samples));
  mpu.setXGyroOffset(-(gx_sum/samples));
  mpu.setYGyroOffset(-(gy_sum/samples));
  mpu.setZGyroOffset(-(gz_sum/samples));
}

void moveStraight(float feet) {
  int speed = (feet > 0) ? baseSpeed : -baseSpeed;
  unsigned long startTime = millis();
  unsigned long targetTime = startTime + (abs(feet) * distancePerFoot);

  while (millis() < targetTime) {
    driveMotors(speed, speed);
    updateYaw();
    delay(10);
  }
  stopMotors();
}

void turnLeft() {
  resetYaw();
  while (abs(yaw) < (turnAngle - turnTolerance)) {
    updateYaw();
    driveMotors(-200, 200);
    delay(10);
  }
  stopMotors();
}

void turnRight() {
  resetYaw();
  while (abs(yaw) < (turnAngle - turnTolerance)) {
    updateYaw();
    driveMotors(200, -200);
    delay(10);
  }
  stopMotors();
}

void updateYaw() {
  int16_t gx, gy, gz;
  mpu.getRotation(&gx, &gy, &gz);
  unsigned long currentTime = millis();
  float deltaTime = (currentTime - prevTime) / 1000.0;
  float gyroZ = (float)gz / gyroSensitivity;
  yaw += (gyroZ + prevGyroZ) * 0.5 * deltaTime;
  prevGyroZ = gyroZ;
  prevTime = currentTime;
}

void resetYaw() {
  yaw = 0;
  prevTime = millis();
  prevGyroZ = 0;
}

void driveMotors(int leftSpeed, int rightSpeed) {
  digitalWrite(IN1, leftSpeed > 0 ? HIGH : LOW);
  digitalWrite(IN2, leftSpeed > 0 ? LOW : HIGH);
  analogWrite(ENA, abs(leftSpeed));
  digitalWrite(IN3, rightSpeed > 0 ? HIGH : LOW);
  digitalWrite(IN4, rightSpeed > 0 ? LOW : HIGH);
  analogWrite(ENB, abs(rightSpeed));
}

void stopMotors() {
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, LOW);
  analogWrite(ENA, 0);
  analogWrite(ENB, 0);
}
